#! /usr/bin/env perl

#####################################################
# Collects numerous statistics from a target BIP-IP and 
# writes the output to the CLI and (optionally) an excel spreadsheet.
#
# https://github.com/jessed/ltmStats
#
# Copyright, F5 Networks, 2009-2020
# Written by Jesse Driskill, F5 Networks
# Contributors
#   Robby Stahl, F5 Networks
#####################################################

## Required libraries
#
use warnings;
use strict;

use Config;
use Getopt::Std;
use Time::HiRes   qw(tv_interval gettimeofday ualarm usleep time);
use Data::Dumper;
use Clone         qw/clone/;       
use List::Util    qw/sum/;
use POSIX         qw/strftime/;
# Use these packages if present, otherwise disable the functionality they provide
my $TRK              = eval { require Term::ReadKey; Term::ReadKey->import(); 1; };
my $NetSNMP          = eval { require Net::SNMP; Net::SNMP->import(); 1; };
my $ExcelWriterXLSX  = eval { require Excel::Writer::XLSX; Excel::Writer::XLSX->import(); 1; };
my $json             = eval { require JSON; JSON->import(); 1; };

$!++;  # No buffer for STDOUT
$SIG{'INT'} = \&exit_now;  # handle ^C nicely

## retrieve and process CLI paramters
#
our (%opts, $XLSXOUT, $JSONOUT, $BYPASS, $DEBUG, $VERBOSE, $PRETTY, $CUSTOMER);
our ($TESTNAME, $COMMENTS, $WAIT);
getopts('d:p:m:l:o:j:s:c:i:w:C:T:M:D:PBvh', \%opts);

# print usage and exit
&usage(0) if $opts{'h'};

my $host      = $opts{'d'} || 'localhost';      # snmp host to poll
my $port      = $opts{'p'} || 161;              # snmp port to poll
my $secondary = $opts{'m'};                     # monitoring host
my $testLen   = $opts{'l'} || 0;                # total duration of test in seconds
my $xlsxName  = $opts{'o'} || '/dev/null';      # xlsx output file name
my $jsonName  = $opts{'j'} || '/dev/null';      # json output file name
my $snmpVer   = $opts{'s'} || 'v2c';            # snmp version
my $comm      = $opts{'c'} || 'public';         # community string    
my $cycleTime = $opts{'i'} || 10;               # polling interval
my $wait      = $opts{'w'} || 0;                # wait time
my $customer  = $opts{'C'} || 'not provided';   # Customer name
my $testname  = $opts{'T'} || 'not provided';   # Test name
my $comments  = $opts{'M'} || 'not provided';   # Test comments/description
$DEBUG        = $opts{'D'} || 0;                # Debug level

my %snmpOpts = ( 'host' => $host,
                 'port' => $port,
                 'comm' => $comm,
                 'ver'  => $snmpVer,
               );

if ($testLen == 0) {
  if ($host =~ 'localhost') { $testLen = 86400; }
  else                      { $testLen = 130;   }
}

# If xlsx output is requested but ExcelWriterXLSX is not present, log a warning
if (!$ExcelWriterXLSX && $xlsxName =~  m/!\/dev\/null/) {
  print "WARNING: xlsx output requested, but module 'Excel::Writer::XLSX' not found.\n";
  print "         xsls file will NOT be created.\n";
}

# The signal handler will throw an error if the output files ($XLSXOUT and $JSONOUT)
# aren't defined. Cosmetic, but irritating.
$DEBUG      = ($opts{'D'} ? 1 : 0);
$XLSXOUT    = ($opts{'o'} ? 1 : 0);
$JSONOUT    = ($opts{'j'} ? 1 : 0);
$VERBOSE    = ($opts{'v'} ? 1 : 0);
$PRETTY     = ($opts{'P'} ? 1 : 0);
$BYPASS     = ($opts{'B'} ? 1 : 0);
$CUSTOMER   = ($opts{'C'} ? 1 : 0);
$TESTNAME   = ($opts{'T'} ? 1 : 0);
$COMMENTS   = ($opts{'m'} ? 1 : 0);


if ($DEBUG) {
  print "
  XLSXOUT:              $XLSXOUT (xlsxName: $xlsxName)
  JSONOUT:              $JSONOUT (jsonName: $jsonName)
  BYPASS:               $BYPASS
  DEBUG:                $DEBUG
  VERBOSE:              $VERBOSE
  PRETTY:               $PRETTY
  CUSTOMER:             $CUSTOMER
  TESTNAME:             $TESTNAME
  COMMENTS:             $COMMENTS
  Term::ReadKey:        $TRK
  Net::SNMP:            $NetSNMP
  Excel::Writer::XLSX:  $ExcelWriterXLSX
  JSON:                 $json

"
}

# additional constants
use constant MB  => 1024*1024;
use constant GB  => 1024*1024*1024;
my $usCycleTime  = $cycleTime * 1_000_000;

##
## Initialization and environment check
##
my $ppsThreshold = 3000;
my (@dataList, @errorList, @staticList, @rowData, @winSize, %formats);
my ($clientCurConns, $clientTotConns, $serverCurConns, $serverTotConns);
my ($cpuUsed, $cpuTicks, $cpuUtil, $cpuPercent, $tmmUtil, $tmmPercent);
my ($totalMemMB, $memUsed, $hMem, $dataVals, $errorVals, $col);
my ($workbook, $raw_data, $chtdata, $charts);
my ($cBytesIn, $cBytesOut, $sBytesIn, $sBytesOut, $tBytesIn, $tBytesOut);
my ($cPktsIn, $cPktsOut, $sPktsIn, $sPktsOut);
my ($cNewConns, $sNewConns, $ccPktsIn, $ccPktsOut, $cBitsIn, $cBitsOut)   = (0, 0, 0, 0, 0, 0);
my ($row, $sBitsIn, $sBitsOut, $tBitsIn, $tBitsOut, $httpReq)             = (0, 0, 0, 0, 0, 0);
my ($iterations, $sleepTime, $runTime, $lastLoopEnd, $loopTime)           = (0, 0, 0, 0, 0);

my ($old, $cur, $out, $xlsData, $test_meta) = ({}, {}, {}, {}, {});
my %pollTimer = ();                 # contains event timestamps
my ($result, $session, $error);
my %json_buffer;

$test_meta->{customer}  = "$customer";
$test_meta->{test_name} = "$testname";
$test_meta->{comments}  = "$comments";

# Build the oid lists and varbind arrays
my %staticOids  = &get_static_oids();
my %dataOids    = &get_f5_oids();
my %errorOids   = &get_err_oids();

my @dutInfoHdrs = ('Host', 'Platform', 'Version', 'Build', 'Memory (MB)', 'TMMs', 'Blades', 
                   'Start Time', 'End Time',
                  );
my @chtDataHdrs = ('RunTime', 'SysCPU', 'TmmCPU', 'Memory', 'Client Mbs In', 
                   'Client Mbs Out', 'Server Mbs In', 'Server Mbs Out','Client CurConns',
                   'Server CurConns', 'Client Conns/Sec', 'Server Conns/Sec',
                   'HTTP Requests/Sec', 'Total CurConns', 
                   'Client PPS In', 'Client PPS Out', 'Server PPS In', 'Server PPS Out',
                  );
my @rawdataHdrs = ('RunTime', 'SysCPU', 'TmmCPU', 'Memory', 'Client bytesIn', 'Client bytesOut', 
                   'Client pktsIn', 'Client pktsOut', 'Server btyesIn', 'Server bytesOut', 
                   'Server pktsIn', 'Server pktsOut', 'Client curConns', 'Client totConns', 
                   'Server curConns', 'Server totConns', 'HTTP Requests',
                   'Clt PVA Bytes In', 'Clt PVA Bytes Out', 'Clt TMM Bytes In', 'Clt TMM Bytes Out',
                   'Svr PVA Bytes In', 'Svr PVA Bytes Out', 'Svr TMM Bytes In', 'Svr TMM Bytes Out',
                  );

while (my ($key, $value) = each(%staticOids)) { push(@staticList, $value); }
while (my ($key, $value) = each(%dataOids))   { push(@dataList, $value); }
while (my ($key, $value) = each(%errorOids))  { push(@errorList, $value); }

# If Net::SNMP is available, use it. If not, use &get_snmp_data
if ($NetSNMP) {
  ($session, $error) = Net::SNMP->session(
    -hostname     => $host,
    -port         => $port,
    -community    => $comm,
    -version      => $snmpVer,
    -maxmsgsize   => 8192,
    -nonblocking  => 0,
  );
  die($error."\n") if ($error);
  $result = $session->get_request( -varbindlist  => \@staticList);
}
else {
  $result = &get_snmp_data(\%staticOids, \%snmpOpts);
}


# print out some information about the DUT being polled
print "Host:          $host\n";
print "Test Duration: $testLen\n";
print "Platform:      $result->{$staticOids{platform}}\n";
                      $totalMemMB = $result->{$staticOids{totalMemory}} / MB;
print "Memory:        $result->{$staticOids{totalMemory}} (".$totalMemMB." MB)\n";
print "# of TMMs:     $result->{$staticOids{cpuCount}}\n";
print "# of blades:   $result->{$staticOids{bladeCount}}\n";
print "LTM Version:   $result->{$staticOids{ltmVersion}} ($result->{$staticOids{ltmBuild}})\n";
#print "LTM Build:     $result->{$staticOids{ltmBuild}}\n";
print "\n";


## determine if logging is required and create the output files
if ($ExcelWriterXLSX) {
  if ($XLSXOUT) {
    $DEBUG && print "Creating workbook ($xlsxName)\n";
    ($workbook, $raw_data, $chtdata, $charts, %formats) = 
        &mk_perf_xls($xlsxName, \@rawdataHdrs, \@chtDataHdrs, \@dutInfoHdrs);
  }

  # If a real xlsx is being written to, record DUT vital info on the first sheet
  if ($xlsxName !~ '/dev/null') {
    $charts->write("A2", $result->{$staticOids{hostName}},    $formats{text});
    $charts->write("B2", $result->{$staticOids{platform}},    $formats{text});
    $charts->write("C2", $result->{$staticOids{ltmVersion}},  $formats{text});
    $charts->write("D2", $result->{$staticOids{ltmBuild}},    $formats{text});
    $charts->write("E2", $totalMemMB,                         $formats{text});
    $charts->write("F2", $result->{$staticOids{cpuCount}},    $formats{text});
    $charts->write("G2", $result->{$staticOids{bladeCount}},  $formats{text});
  }
}

$test_meta->{host_name}     = $result->{$staticOids{hostName}};
$test_meta->{platform}      = $result->{$staticOids{platform}};
$test_meta->{cpu_count}     = $result->{$staticOids{cpuCount}};
$test_meta->{blade_count}   = $result->{$staticOids{bladeCount}};
$test_meta->{totalMem}      = $result->{$staticOids{totalMemory}};
$test_meta->{totalMemMB}    = $totalMemMB;
$test_meta->{ltm_version}   = $result->{$staticOids{ltmVersion}};
$test_meta->{ltm_build}     = $result->{$staticOids{ltmBuild}};
$test_meta->{interval}      = $cycleTime; # poll interval 
$test_meta->{poll_count}    = 0;

# coerce a few of these values into numbers, important for javascript output
$test_meta->{cpu_count}     += 0;
$test_meta->{totalMem}      += 0;
$test_meta->{totalMemMB}    += 0;
$test_meta->{blade_count}   += 0;
$test_meta->{interval}      += 0;

if ($json) {
  %json_buffer = ( 'metadata' => {},
                   'perfdata' => [],
                   'names'    => [],
                 );
};

##
## Begin Main
##

# loop until start-of-test is detected
if (!$BYPASS) {
  if ($NetSNMP && $opts{'m'}) {
    my ($watchhost, $error) = Net::SNMP->session(
      -hostname     => $secondary,
      -community    => $comm,
      -version      => $snmpVer,
      -maxmsgsize   => 8192,
      -nonblocking  => 0,
    );
    die($error."\n") if ($error);
    &detect_test_netsnmp($watchhost, \%dataOids, $ppsThreshold);
  }
  elsif ($NetSNMP) {
    &detect_test_netsnmp($session, \%dataOids, $ppsThreshold);
  }
  else {
    &detect_test_snmpget(\%dataOids, \%snmpOpts, $ppsThreshold);
  } 
}

if ($wait) {
  print "Pausing for ".$wait." seconds while for ramp-up\n";
  sleep($wait);
}

# start active polling
# Update test metadata with polling start time
$test_meta->{start_time}        = sprintf("%d", Time::HiRes::time);
$test_meta->{start_time}        += 0;
$test_meta->{start_time_pretty} = strftime('%F %R', localtime($test_meta->{start_time}));

# Update pollTimer with test start time
$pollTimer{testStart} = [gettimeofday];

do {
  my $out = {};
  $pollTimer{activeStart} = [gettimeofday];


  # get snmp stats from DUT
  if ($NetSNMP) {
    $dataVals = $session->get_request( -varbindlist  => \@dataList);
    # die($session->error."\n") if (!defined($dataVals));
    if (!defined($dataVals)) {
        print "ERROR: No data from DUT. Terminating polling, attempting to write data...\n";
        &exit_now();
    }
  }
  else {
    $dataVals = &get_snmp_data(\%dataOids, \%snmpOpts);
  }

  $pollTimer{queryTime}     = tv_interval($pollTimer{activeStart});
  $pollTimer{lastPollTime}  = $pollTimer{pollTime};
  $pollTimer{pollTime}      = [gettimeofday];


  # Confirm at least one full iteration has completed
  if ($pollTimer{lastLoopEnd}) {
    $loopTime = tv_interval($pollTimer{lastPollTime});
    $runTime  = tv_interval($pollTimer{testStart});
  } else {
    $loopTime = 0;
  }

  # Before any real processing, remove any non-numeric values (i.e. 'noSuchInstance')
  for my $n (keys(%dataOids)) {
    if ($dataVals->{$dataOids{$n}} =~ /\D+/) {
      $xlsData->{$n} = 1;
    }
    else {
      $xlsData->{$n} = $dataVals->{$dataOids{$n}};
    }
  }

  # %cur contains data collected this polling period
  # %out contains data being written to the CLI

  # CPU and TMM time used
  $cur->{cpuTotalTicks}   = sum(@$xlsData{qw/ssCpuRawUser ssCpuRawNice ssCpuRawSystem ssCpuRawIdle/});
  $cur->{cpuIdleTicks}    = $xlsData->{ssCpuRawIdle};
  $cur->{tmmTotal}        = $xlsData->{tmmTotalCycles};
  $cur->{tmmIdle}         = sum(@$xlsData{qw/tmmIdleCycles tmmSleepCycles/});
  $cur->{memUsed}         = $xlsData->{tmmTotalMemoryUsed};
  $cur->{clientCurConns}  = $xlsData->{tmmClientCurConns};
  $cur->{serverCurConns}  = $xlsData->{tmmServerCurConns};
  $cur->{clientTotConns}  = $xlsData->{tmmClientTotConns};
  $cur->{serverTotConns}  = $xlsData->{tmmServerTotConns};
  $cur->{totHttpReq}      = $xlsData->{sysStatHttpRequests};
  $cur->{cPvaBytesIn}     = $xlsData->{pvaClientBytesIn};     # Client PVA bytes in
  $cur->{cPvaBytesOut}    = $xlsData->{pvaClientBytesOut};    # Client PVA bytes out
  $cur->{cTmmBytesIn}     = $xlsData->{tmmClientBytesIn};     # Client TMM bytes in
  $cur->{cTmmBytesOut}    = $xlsData->{tmmClientBytesOut};    # Client TMM bytes out
  $cur->{sPvaBytesIn}     = $xlsData->{pvaServerBytesIn};     # Server PVA bytes in
  $cur->{sPvaBytesOut}    = $xlsData->{pvaServerBytesOut};    # Server PVA bytes out
  $cur->{sTmmBytesIn}     = $xlsData->{tmmServerBytesIn};     # Server TMM bytes in
  $cur->{sTmmBytesOut}    = $xlsData->{tmmServerBytesOut};    # Server TMM bytes out
  $cur->{cTmmPktsIn}      = $xlsData->{tmmClientPktsIn};      # Client TMM packets in
  $cur->{cTmmPktsOut}     = $xlsData->{tmmClientPktsOut};     # Client TMM packets Out
  $cur->{sTmmPktsIn}      = $xlsData->{tmmServerPktsIn};      # Server TMM packets in
  $cur->{sTmmPktsOut}     = $xlsData->{tmmServerPktsOut};     # Server TMM packets Out
  $cur->{cPvaPktsIn}      = $xlsData->{pvaClientPktsIn};      # Client PVA packets in
  $cur->{cPvaPktsOut}     = $xlsData->{pvaClientPktsOut};     # Client PVA packets Out
  $cur->{sPvaPktsIn}      = $xlsData->{pvaServerPktsIn};      # Server PVA packets in
  $cur->{sPvaPktsOut}     = $xlsData->{pvaServerPktsOut};     # Server PVA packets Out
  $cur->{cBytesIn}        = $cur->{cTmmBytesIn};              # Client total bytes in
  $cur->{cBytesOut}       = $cur->{cTmmBytesOut};             # Client total bytes out
  $cur->{sBytesIn}        = $cur->{sTmmBytesIn};              # Server total bytes in
  $cur->{sBytesOut}       = $cur->{sTmmBytesOut};             # Server total bytes out
  $cur->{cPktsIn}         = $cur->{cTmmPktsIn};               # Client total packets in
  $cur->{cPktsOut}        = $cur->{cTmmPktsOut};              # Client total packets out
  $cur->{sPktsIn}         = $cur->{sTmmPktsIn};               # Server total packets in
  $cur->{sPktsOut}        = $cur->{sTmmPktsOut};              # Server total packets out
  $cur->{cpuUtil}         = sprintf("%.2f", cpu_util(delta("cpuTotalTicks"), delta("cpuIdleTicks")));
  $cur->{tmmUtil}         = sprintf("%.2f", cpu_util(delta("tmmTotal"), delta("tmmIdle")));
  $cur->{runTime}         = $runTime;

  if ($runTime) { 
    $out->{runTime}       = $runTime;
    $out->{httpReq}       = sprintf("%.0f", delta("totHttpReq") / $loopTime);
    $out->{cNewConns}     = sprintf("%.0f", delta("clientTotConns") / $loopTime);
    $out->{sNewConns}     = sprintf("%.0f", delta("serverTotConns") / $loopTime);
    $out->{cCurConns}     = sprintf("%.0f", $cur->{clientCurConns});
    $out->{sCurConns}     = sprintf("%.0f", $cur->{serverCurConns});
    $out->{cBitsIn}       = sprintf("%.0f", bytes_to_Mbits(delta("cBytesIn"))  / $loopTime);
    $out->{cBitsOut}      = sprintf("%.0f", bytes_to_Mbits(delta("cBytesOut")) / $loopTime);
    $out->{sBitsIn}       = sprintf("%.0f", bytes_to_Mbits(delta("sBytesIn"))  / $loopTime);
    $out->{sBitsOut}      = sprintf("%.0f", bytes_to_Mbits(delta("sBytesOut")) / $loopTime);
    $out->{cPktsIn}       = sprintf("%.0f", delta("cPktsIn")  / $loopTime);
    $out->{cPktsOut}      = sprintf("%.0f", delta("cPktsOut") / $loopTime);
    $out->{sPktsIn}       = sprintf("%.0f", delta("sPktsIn")  / $loopTime);
    $out->{sPktsOut}      = sprintf("%.0f", delta("sPktsOut") / $loopTime);
    $out->{memUsed}       = sprintf("%.0f", bytes_to_MB($cur->{memUsed}));
    $out->{cpuUtil}       = sprintf("%.2f", cpu_util(delta("cpuTotalTicks"), delta("cpuIdleTicks")));
    $out->{tmmUtil}       = sprintf("%.2f", cpu_util(delta("tmmTotal"), delta("tmmIdle")));

    # Print real-time stats to terminal
    # Use Term::Readkey if present, otherwise use 'format' statements
    if ($TRK) {
      &print_cli($out);  
    }
    else {
format STDOUT_TOP =
@>>>>>> @>>>>>> @>>>>>> @>>>>>>>> @>>>>>> @>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>> @>>>>>>>
"Time", "sysCPU", "tmmCPU", "Mem (MB)", "C-CPS", "S-CPS", "Client CC", "Server CC", "In/Mbs", "Out/Mbs"
.
format =
@###.## @>>>>>> @>>>>>> @>>>>>>>> @>>>>>> @>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>> @>>>>>>>
@$out{qw/runTime cpuUtil tmmUtil memUsed cNewConns sNewConns cCurConns sCurConns cBitsIn cBitsOut/}
.
write;

    }

    # Increment $row, used to track which iteration this is and which xlsx row should be written to
    $row++;
    if ($ExcelWriterXLSX) {
      if ($XLSXOUT) {
        &write_rawdata($raw_data, $row, $cur, %formats);
        $raw_data->write($row, 0, $out->{runTime}, $formats{decimal4});
        $raw_data->write($row, 1, $out->{cpuUtil}, $formats{decimal2});
        $raw_data->write($row, 2, $out->{tmmUtil}, $formats{decimal2});

        $raw_data->write( $row, 
                          3,
                          [$cur->{memUsed},
                          sprintf("%.0f", $cur->{cBytesIn}),
                          sprintf("%.0f", $cur->{cBytesOut}),
                          sprintf("%.0f", $cur->{cPktsIn}),
                          sprintf("%.0f", $cur->{cPktsOut}),
                          sprintf("%.0f", $cur->{sBytesIn}),
                          sprintf("%.0f", $cur->{sBytesOut}),
                          sprintf("%.0f", $cur->{sPktsIn}),
                          sprintf("%.0f", $cur->{sPktsOut}),
                          sprintf("%.0f", $cur->{clientCurConns}),
                          sprintf("%.0f", $cur->{clientTotConns}),
                          sprintf("%.0f", $cur->{serverCurConns}),
                          sprintf("%.0f", $cur->{serverTotConns}),
                          sprintf("%.0f", $cur->{totHttpReq}),
                          sprintf("%.0f", $cur->{cPvaBytesIn}),
                          sprintf("%.0f", $cur->{cPvaBytesOut}),
                          sprintf("%.0f", $cur->{cBytesIn}),
                          sprintf("%.0f", $cur->{cBytesOut}),
                          sprintf("%.0f", $cur->{sPvaBytesIn}),
                          sprintf("%.0f", $cur->{sPvaBytesOut}),
                          sprintf("%.0f", $cur->{sBytesIn}),
                          sprintf("%.0f", $cur->{sBytesOut})],
                         $formats{'standard'});
      }
    }

      if ($json) {
        # Save data in json_buffer in case that output has been requested
        # Make sure we 'numify' the data-points before writing them out
        foreach my $k (keys %$out) { $out->{$k} += 0; }
        push(@{$json_buffer{perfdata}}, $out);
        $test_meta->{poll_count} = $row;

        # Gather the stat names included
        if (@{$json_buffer{names}} == 0) {
          foreach my $n (keys %$out) { push(@{$json_buffer{names}}, $n); }
        }
      }
    }

    # update 'old' data with the current values to calculate delta next cycle
  $old = clone($cur);

  # Calculate how much time this iteration has required to determine how
  # long we should sleep before beginning the next cycle
  $pollTimer{iterationTime} = tv_interval($pollTimer{activeStart});
  $sleepTime = $cycleTime - $pollTimer{iterationTime};

  my $wakeTime = Time::HiRes::time() + $sleepTime;

  if ($DEBUG >1 ) {
    print "Query: $pollTimer{queryTime}, iteration: $pollTimer{iterationTime}, sleep: $sleepTime, loop: $loopTime\n";
  }

  $pollTimer{lastLoopEnd} = [gettimeofday];
  while (Time::HiRes::time() < $wakeTime) {
    Time::HiRes::usleep(100);
  }
  $iterations++;
} while ($runTime < $testLen);

# polling is now complete, time to write the output files (if requested)

# Record end time
$test_meta->{end_time}        = sprintf("%d", Time::HiRes::time);
$test_meta->{end_time}        += 0;
$test_meta->{end_time_pretty} = strftime('%F %R', localtime($test_meta->{end_time}));

if ($json) {
  if ($JSONOUT) {
    print "Writing JSON output file: $jsonName\n";
    &write_json($jsonName, \%json_buffer, $test_meta);
  }
}

if ($ExcelWriterXLSX) {
  if ($XLSXOUT) {
    print "Writing XLSX output file: $xlsxName\n";
    &write_chartData($chtdata, \%formats, $row);
    &mk_charts($workbook, $charts, $row, $test_meta->{totalMemMB});
    $charts->write("H2", $test_meta->{start_time_pretty},  $formats{text});
    $charts->write("I2", $test_meta->{end_time_pretty},  $formats{text});

    # close the workbook; required for the workbook to be usable.
    &close_xls($workbook);
  }
}


##
## Subs
##

# utility subs
sub delta           { 
  if ($DEBUG > 3) {
    printf("($_[0]) Old: %.0f   Cur: %.0f   Diff: %.0f\n", $old->{$_[0]}, $cur->{$_[0]}, $cur->{$_[0]} - $old->{$_[0]});
  }
  return (!exists $old->{$_[0]} ? 0 : $cur->{$_[0]} - $old->{$_[0]}); 
}
sub bytes_to_Mbits  { return sprintf("%.0f", ($_[0] * 8) / 1_000_000) };
sub bytes_to_MB     { return sprintf("%d", $_[0] / (1024 * 1024)) };
sub cpu_util        { return ($_[0] == 0) ? 0 : (($_[0] - $_[1]) / $_[0]) * 100 };

# delay the start of the script until the test is detected through pkts/sec
sub detect_test_snmpget() {
  my $oids = shift;
  my $opts = shift;
  my $pkts = shift;

  print "\nWaiting for test to begin...\n";

  while (1) {
    $DEBUG && print "snmpget -t2 -Ovq -c $opts->{comm} $opts->{host} $$oids{tmmClientPktsIn}\n";
    my $r1 = `snmpget -t2 -Ovq -c $opts->{comm} $opts->{host} $$oids{tmmClientPktsIn}`;
    sleep(4);
    my $r2 = `snmpget -t2 -Ovq -c $opts->{comm} $opts->{host} $$oids{tmmClientPktsIn}`;

    my $delta = $r2 - $r1;
  
    if ($delta > $pkts) {
      print "Start of test detected...\n\n";
      return;
    }
  }
}
sub detect_test_netsnmp() {
  my $snmp = shift;
  my $oids = shift;
  my $pkts = shift;

  print "\nWaiting for test to begin...\n";

  while (1) {
    my $r1 = $snmp->get_request($$oids{tmmClientPktsIn});
    sleep(4);
    my $r2 = $snmp->get_request($$oids{tmmClientPktsIn});

    my $delta = $r2->{$$oids{tmmClientPktsIn}} - $r1->{$$oids{tmmClientPktsIn}};
  
    if ($delta > $pkts) {
      print "Start of test detected...\n\n";
      return;
    }
  }
}

# Retrieve snmp data using snmpget
sub get_snmp_data() {
  my $oids = shift;
  my $opts = shift;

  my $oidlist = "";
  my @output;
  my ($oid, $value);
  my (%results, %data);

  for my $o (values(%$oids)) { $oidlist = $oidlist.' '.$o; };
  @output = `snmpget -t2 -Onq -c $opts->{comm} $opts->{host} $oidlist`;

  foreach (@output) {
    chomp($_);
    my ($oid, $value) = split(' ', $_);
    $data{$oid} = $value;
  }
  return(\%data);
}

# Write data to the 'raw_data' tab
sub write_rawdata() {
  my $worksheet = shift;
  my $row       = shift;
  my $data      = shift;
  my $formats   = shift;

  $raw_data->write( $row, 0, $data->{runTime}, $formats{decimal4});
  $raw_data->write( $row, 1, $data->{cpuUtil}, $formats{decimal2});
  $raw_data->write( $row, 2, $data->{tmmUtil}, $formats{decimal2});
  $raw_data->write( $row,
                    3,
                    [$data->{memUsed},
                    sprintf("%.0f", $data->{cBytesIn}),
                    sprintf("%.0f", $data->{cBytesOut}),
                    sprintf("%.0f", $data->{cPktsIn}),
                    sprintf("%.0f", $data->{cPktsOut}),
                    sprintf("%.0f", $data->{sBytesIn}),
                    sprintf("%.0f", $data->{sBytesOut}),
                    sprintf("%.0f", $data->{sPktsIn}),
                    sprintf("%.0f", $data->{sPktsOut}),
                    sprintf("%.0f", $data->{clientCurConns}),
                    sprintf("%.0f", $data->{clientTotConns}),
                    sprintf("%.0f", $data->{serverCurConns}),
                    sprintf("%.0f", $data->{serverTotConns}),
                    sprintf("%.0f", $data->{totHttpReq}),
                    sprintf("%.0f", $data->{cPvaBytesIn}),
                    sprintf("%.0f", $data->{cPvaBytesOut}),
                    sprintf("%.0f", $data->{cBytesIn}),
                    sprintf("%.0f", $data->{cBytesOut}),
                    sprintf("%.0f", $data->{sPvaBytesIn}),
                    sprintf("%.0f", $data->{sPvaBytesOut}),
                    sprintf("%.0f", $data->{sBytesIn}),
                    sprintf("%.0f", $data->{sBytesOut})],
                    $formats{'standard'});
}


sub write_chartData() {
  my $worksheet = shift;
  my $formats   = shift;
  my $numRows   = shift;
  my ($row0, $row1, $row2, $col, $cTime, $rowTime, $runDiff, $rowCPU, $rowTMM);

  # columns in 'raw_data' worksheet
  my %r = ('rowtime'      => 'A',
           'rowcpu'       => 'B',
           'rowtmm'       => 'C',
           'memutil'      => 'D',
           'cBytesIn'     => 'E',
           'cBytesOut'    => 'F',
           'cPktsIn'      => 'G',
           'cPktsOut'     => 'H',
           'sBytesIn'     => 'I',
           'sBytesOut'    => 'J',
           'sPktsIn'      => 'K',
           'sPktsOut'     => 'L',
           'cltCurConns'  => 'M',
           'cltTotConns'  => 'N',
           'svrCurConns'  => 'O',
           'svrTotConns'  => 'P',
           'httpRequests' => 'Q',
           'cPvaBytesIn'  => 'R',
           'cPvaBytesOut' => 'S',
           'cTmmPktsIn'   => 'T',
           'cTmmPktsOut'  => 'U',
           'sPvaBytesIn'  => 'V',
           'sPvaBytesOut' => 'W',
           'sTmmPktsIn'   => 'X',
           'sTmmPktsOut'  => 'Y',
          );

  for ($row0 = 1; $row0 < $numRows; $row0++) {
    $row1    = $row0+1;
    $row2    = $row0+2;
    $cTime   = 'raw_data!'.$r{'rowtime'}.$row2.'-raw_data!'.$r{'rowtime'}.$row1;

    # splitting these out is required so different formats can be applied
    $rowTime = '=raw_data!'.$r{'rowtime'}.$row2;
    $rowCPU  = '=raw_data!'.$r{'rowcpu'}.$row2;
    $rowTMM  = '=raw_data!'.$r{'rowtmm'}.$row2;
    $runDiff = '='.$cTime;
   
    # @rowData contains formulas required to populate the chart_data worksheet
    # All calculations are performed on the values in the 'raw_data' worksheet
    # In order, they are: memutil, client bits/sec in, client bits/sec out,
    #                     server bits/sec in, server bits/sec out, client conns/sec,
    #                     server conns/sec
    @rowData = (
      '=(raw_data!'   .$r{'memutil'}    .$row2.'/'.MB.')',
      '=((((raw_data!'.$r{'cBytesIn'} .$row2.'-raw_data!'.$r{'cBytesIn'} .$row1.')/('.$cTime.'))*8)/1000000)',
      '=((((raw_data!'.$r{'cBytesOut'}.$row2.'-raw_data!'.$r{'cBytesOut'}.$row1.')/('.$cTime.'))*8)/1000000)',
      '=((((raw_data!'.$r{'sBytesIn'} .$row2.'-raw_data!'.$r{'sBytesIn'} .$row1.')/('.$cTime.'))*8)/1000000)',
      '=((((raw_data!'.$r{'sBytesOut'}.$row2.'-raw_data!'.$r{'sBytesOut'}.$row1.')/('.$cTime.'))*8)/1000000)',
      '=raw_data!'    .$r{'cltCurConns'}.$row2,
      '=raw_data!'    .$r{'svrCurConns'}.$row2,
      '=((raw_data!'  .$r{'cltTotConns'}.$row2.'-raw_data!'.$r{'cltTotConns'}.$row1.')/('.$cTime.'))',
      '=((raw_data!'  .$r{'svrTotConns'}.$row2.'-raw_data!'.$r{'svrTotConns'}.$row1.')/('.$cTime.'))',
      '=((raw_data!'  .$r{'httpRequests'}.$row2.'-raw_data!'.$r{'httpRequests'}.$row1.')/('.$cTime.'))',
      '=raw_data!'    .$r{'cltCurConns'}.$row2.'+raw_data!'.$r{'svrCurConns'}.$row2,
      '=(raw_data!'   .$r{'cPktsIn'}.$row2.'-raw_data!'.$r{'cPktsIn'}.$row1.')/('.$cTime.')',
      '=(raw_data!'   .$r{'cPktsOut'}.$row2.'-raw_data!'.$r{'cPktsOut'}.$row1.')/('.$cTime.')',
      '=(raw_data!'   .$r{'sPktsIn'}.$row2.'-raw_data!'.$r{'sPktsIn'}.$row1.')/('.$cTime.')',
      '=(raw_data!'   .$r{'sPktsOut'}.$row2.'-raw_data!'.$r{'sPktsOut'}.$row1.')/('.$cTime.')',
    );

    if ($DEBUG > 1) { print Dumper(\@rowData); }
    $worksheet->write($row0, 0, $rowTime,  ${$formats}{'decimal0'});
    $worksheet->write($row0, 1, $rowCPU,   ${$formats}{'decimal0'});
    $worksheet->write($row0, 2, $rowTMM,   ${$formats}{'decimal0'});
    $worksheet->write($row0, 3, \@rowData, ${$formats}{'standard'});
  }
}

## returns a has containing the data-oids
sub get_f5_oids() {
  my %oidlist = (
      'ssCpuRawUser'            => '.1.3.6.1.4.1.2021.11.50.0',
      'ssCpuRawNice'            => '.1.3.6.1.4.1.2021.11.51.0',
      'ssCpuRawSystem'          => '.1.3.6.1.4.1.2021.11.52.0',
      'ssCpuRawIdle'            => '.1.3.6.1.4.1.2021.11.53.0',
      'ssCpuRawWait'            => '.1.3.6.1.4.1.2021.11.54.0',
      'ssCpuRawKernel'          => '.1.3.6.1.4.1.2021.11.55.0',
      'ssCpuRawInterrupt'       => '.1.3.6.1.4.1.2021.11.56.0',
      'ssCpuRawSoftIRQ'         => '.1.3.6.1.4.1.2021.11.61.0',
      'tmmTotalCycles'          => '.1.3.6.1.4.1.3375.2.1.1.2.1.41.0',
      'tmmIdleCycles'           => '.1.3.6.1.4.1.3375.2.1.1.2.1.42.0',
      'tmmSleepCycles'          => '.1.3.6.1.4.1.3375.2.1.1.2.1.43.0',
      'tmmTotalMemoryUsed'      => '.1.3.6.1.4.1.3375.2.1.1.2.1.45.0',
      'tmmClientBytesIn'        => '.1.3.6.1.4.1.3375.2.1.1.2.1.3.0',
      'tmmClientBytesOut'       => '.1.3.6.1.4.1.3375.2.1.1.2.1.5.0',
      'tmmClientPktsIn'         => '.1.3.6.1.4.1.3375.2.1.1.2.1.2.0',
      'tmmClientPktsOut'        => '.1.3.6.1.4.1.3375.2.1.1.2.1.4.0',
      'tmmClientTotConns'       => '.1.3.6.1.4.1.3375.2.1.1.2.21.8.0',
      'tmmClientCurConns'       => '.1.3.6.1.4.1.3375.2.1.1.2.21.9.0',
      'tmmServerBytesIn'        => '.1.3.6.1.4.1.3375.2.1.1.2.1.10.0',
      'tmmServerBytesOut'       => '.1.3.6.1.4.1.3375.2.1.1.2.1.12.0',
      'tmmServerPktsIn'         => '.1.3.6.1.4.1.3375.2.1.1.2.1.9.0',
      'tmmServerPktsOut'        => '.1.3.6.1.4.1.3375.2.1.1.2.1.11.0',
      'tmmServerTotConns'       => '.1.3.6.1.4.1.3375.2.1.1.2.21.15.0',
      'tmmServerCurConns'       => '.1.3.6.1.4.1.3375.2.1.1.2.21.16.0',
      'sysStatHttpRequests'     => '.1.3.6.1.4.1.3375.2.1.1.2.1.56.0',
      'pvaClientPktsIn'         => '.1.3.6.1.4.1.3375.2.1.1.2.1.16.0',
      'pvaClientBytesIn'        => '.1.3.6.1.4.1.3375.2.1.1.2.1.17.0',
      'pvaClientPktsOut'        => '.1.3.6.1.4.1.3375.2.1.1.2.1.18.0',
      'pvaClientBytesOut'       => '.1.3.6.1.4.1.3375.2.1.1.2.1.19.0',
      'pvaServerPktsIn'         => '.1.3.6.1.4.1.3375.2.1.1.2.1.23.0',
      'pvaServerBytesIn'        => '.1.3.6.1.4.1.3375.2.1.1.2.1.24.0',
      'pvaServerPktsOut'        => '.1.3.6.1.4.1.3375.2.1.1.2.1.25.0',
      'pvaServerBytesOut'       => '.1.3.6.1.4.1.3375.2.1.1.2.1.26.0',
      'pvaClientTotConns'       => '.1.3.6.1.4.1.3375.2.1.1.2.1.21.0',
      'pvaClientCurConns'       => '.1.3.6.1.4.1.3375.2.1.1.2.1.22.0',
      'pvaServerTotConns'       => '.1.3.6.1.4.1.3375.2.1.1.2.1.28.0',
      'pvaServerCurConns'       => '.1.3.6.1.4.1.3375.2.1.1.2.1.29.0',
  );
  return(%oidlist);
}

sub get_profile_oids() {
  my %profileOids = ( 'userStatProfile1'  => '1.3.6.1.4.1.3375.2.2.6.19.2.3.1',
  );

  return(%profileOids);
}

# returns a hash containing oids that will be polled only once
sub get_static_oids() {
  my %oidlist = ( 'ltmVersion'   => '.1.3.6.1.4.1.3375.2.1.4.2.0',
                  'ltmBuild'     => '.1.3.6.1.4.1.3375.2.1.4.3.0',
                  'platform'     => '.1.3.6.1.4.1.3375.2.1.3.3.1.0',
                  'cpuCount'     => '.1.3.6.1.4.1.3375.2.1.1.2.1.39.0',   # active blades only
                  'totalMemory'  => '.1.3.6.1.4.1.3375.2.1.1.2.21.28.0',  # active blades only
                  'hostName'     => '.1.3.6.1.4.1.3375.2.1.6.2.0',
                  'bladeCount'   => '.1.3.6.1.4.1.3375.2.1.7.4.1.0',
                );

  return(%oidlist);
}

# returns a has containing oids that track errors
sub get_err_oids() {
  my %oidlist = (
      'incomingPktErrors'   => '.1.3.6.1.4.1.3375.2.1.1.2.1.47.0',
      'outgoingPktErrors'   => '.1.3.6.1.4.1.3375.2.1.1.2.1.48.0',
      'IPDroppedPkts'       => '.1.3.6.1.4.1.3375.2.1.1.2.7.4.0',
      'vipNonSynDeny'       => '.1.3.6.1.4.1.3375.2.1.1.2.21.20.0',
      'cmpConnRedirected'   => '.1.3.6.1.4.1.3375.2.1.1.2.21.23.0',
      'connMemErrors'       => '.1.3.6.1.4.1.3375.2.1.1.2.21.24.0',
      'sysIpStatDropped'    => '.1.3.6.1.4.1.3375.2.1.1.2.7.4.0',
  );

  return(%oidlist);
}

sub mk_perf_xls() {
  my $fname   = shift;
  my $rawHdrs = shift;
  my $chtHdrs = shift;
  my $dutHdrs = shift;
  my %hdrfmts;

  ## create Excel workbook
  my $workbook = Excel::Writer::XLSX->new($fname);

  # define formatting
  if ($DEBUG > 1) { print "Generating workbook formats (mk_perf_xls())\n"; }
  $hdrfmts{'text'}     = $workbook->add_format(align => 'center');
  $hdrfmts{'headers'}  = $workbook->add_format(align => 'center', bold => 1, bottom => 1);
  $hdrfmts{'standard'} = $workbook->add_format(align => 'center', num_format => '#,##0');
  $hdrfmts{'decimal0'} = $workbook->add_format(align => 'center', num_format => '#,##0');
  $hdrfmts{'decimal1'} = $workbook->add_format(align => 'center', num_format => '0.0');
  $hdrfmts{'decimal2'} = $workbook->add_format(align => 'center', num_format => '0.00');
  $hdrfmts{'decimal4'} = $workbook->add_format(align => 'center', num_format => '0.0000');

  ## create worksheets
  # the 'charts' worksheet will contain graphs using data from the 'chtData' sheet.
  my $charts = $workbook->add_worksheet('charts');
  $charts->hide_gridlines(2);
  $charts->set_zoom(100);
  $charts->set_column('A:A', 30);
  $charts->set_column('B:D', 10);
  $charts->set_column('E:E', 15);
  $charts->set_column('F:G', 10);
  $charts->set_column('H:I', 14);
  $charts->activate();

  # create the worksheet that will contain the data used for the charts
  my $chtData = $workbook->add_worksheet('chart_data');
  $chtData->set_zoom(80);
  $chtData->set_column('A:C', 9);
  $chtData->set_column('D:G', 15);
  $chtData->set_column('H:R', 18);

  # contains the raw data retrieved with SNMP
  my $rawdata = $workbook->add_worksheet('raw_data');
  $rawdata->set_zoom(80);
  $rawdata->set_column('A:C', 9);
  $rawdata->set_column('D:Z', 17);

  $charts->write( 0, 0, $dutHdrs, $hdrfmts{'headers'});
  $chtData->write(0, 0, $chtHdrs, $hdrfmts{'headers'});
  $rawdata->write(0, 0, $rawHdrs, $hdrfmts{'headers'});

  return($workbook, $rawdata, $chtData, $charts, %hdrfmts);
}

# Create the charts that will be displayed on the 'charts' sheet
sub mk_charts() {
  my $fname     = shift;
  my $worksheet = shift;
  my $numRows   = shift;
  my $memoryMB  = shift;

  if ($DEBUG > 1) { print "Writing 'charts' worksheet.\n"; }

  ## CPU Usage chart
  my $chtCpu  = $fname->add_chart( type => 'line', embedded => 1);
  $chtCpu->set_title ( name => 'CPU Utilization', name_font => { size => 12, bold => 0} );
  $chtCpu->set_x_axis( name => 'Time (Seconds)', num_font => { rotation => 45 } );
  $chtCpu->set_y_axis( name => 'CPU Usage', min => 0, max => 100 );
  $chtCpu->set_legend( position => 'bottom' );
  $chtCpu->add_series(
    name        => '=chart_data!$B$1',
    values      => '=chart_data!$B$2:$B$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'blue' },
    marker      => { type  => 'none' },
  );
  $chtCpu->add_series(
    name        => '=chart_data!$C$1',
    values      => '=chart_data!$C$2:$C$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'red' },
    marker      => { type  => 'none' },
  );
  $worksheet->insert_chart( 'A4', $chtCpu, 10, 0);

  ## Connection Rate
  my $chtCPS  = $fname->add_chart( type => 'line', embedded => 1);
  $chtCPS->set_title ( name => 'Connection/Transaction Rate', name_font => { size => 12, bold => 0} );
  $chtCPS->set_x_axis( name => 'Time (Seconds)', num_font => { rotation => 45 } );
  $chtCPS->set_y_axis( name => 'Connections/Second', min => 0);
  $chtCPS->set_legend( position => 'bottom' );
  $chtCPS->add_series(  # Client Connection rate
    name        => '=chart_data!$K$1',
    values      => '=chart_data!$K$2:$K$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'blue' },
    marker      => { type  => 'none' },
  );
  $chtCPS->add_series(  # Server Connection rate
    name        => '=chart_data!$L$1',
    values      => '=chart_data!$L$2:$L$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'red' },
    marker      => { type  => 'none' },
  );
  $chtCPS->add_series(  # HTTP Transaction rate
    name        => '=chart_data!$M$1',
    values      => '=chart_data!$M$2:$M$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'green' },
    marker      => { type  => 'none' },
  );
  $worksheet->insert_chart( 'E4', $chtCPS, 50, 0);

  ## Throughput chart
  my $chtTput = $fname->add_chart( type => 'line', embedded => 1);
  $chtTput->set_title ( name => 'Client Throughput', name_font => { size => 12, bold => 0} );
  $chtTput->set_x_axis( name => 'Time (Seconds)', num_font => { rotation => 45 } );
  $chtTput->set_y_axis( name => 'Throughput (Mbps)', min => 0);
  $chtTput->set_legend( position => 'bottom' );
  $chtTput->add_series(
    name        => '=chart_data!$E$1',
    values      => '=chart_data!$E$2:$E$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'blue' },
    marker      => { type  => 'none' },
  );
  $chtTput->add_series(
    name        => '=chart_data!$F$1',
    values      => '=chart_data!$F$2:$F$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'red' },
    marker      => { type  => 'none' },
  );
## Removing the server-side throughput data from the charts.
## It's unhelpful and clutters the chart.
## Preserving the code for those few situations that warrant it.
## TODO: Convert this sloppy approach to a cli switch
#  $chtTput->add_series(
#    name        => '=chart_data!$G$1',
#    values      => '=chart_data!$G$2:$G$'.($numRows-1),
#    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
#    line        => { color => 'yellow' },
#    marker      => { type  => 'none' },
#  );
#  $chtTput->add_series(
#    name        => '=chart_data!$H$1',
#    values      => '=chart_data!$H$2:$H$'.($numRows-1),
#    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
#    line        => { color => 'green' },
#    marker      => { type  => 'none' },
#  );
  $worksheet->insert_chart( 'A19', $chtTput, 10, 0);

  ## Packet Rate
  my $chtPPS  = $fname->add_chart( type => 'line', embedded => 1);
  $chtPPS->set_title ( name => 'Packet Rate', name_font => { size => 12, bold => 0} );
  $chtPPS->set_x_axis( name => 'Time (Seconds)', num_font => { rotation => 45 } );
  $chtPPS->set_y_axis( name => 'Packet Rate', min => 0);
  $chtPPS->set_legend( position => 'bottom' );
  $chtPPS->add_series(  # Client Pkts In
    name        => '=chart_data!$O$1',
    values      => '=chart_data!$O$2:$O$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'blue' },
    marker      => { type  => 'none' },
  );
  $chtPPS->add_series(  # Client Pkts Out
    name        => '=chart_data!$P$1',
    values      => '=chart_data!$P$2:$P$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'red' },
    marker      => { type  => 'none' },
  );
## Same situation as the server-side throughput (see above)
## TODO: Convert this to a CLI switch rather than just commenting it out
#  $chtPPS->add_series(  # Server Pkts In
#    name        => '=chart_data!$Q$1',
#    values      => '=chart_data!$Q$2:$Q$'.($numRows-1),
#    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
#    line        => { color => 'green' },
#    marker      => { type  => 'none' },
#  );
#  $chtPPS->add_series(  # Server Pkts Out
#    name        => '=chart_data!$R$1',
#    values      => '=chart_data!$R$2:$R$'.($numRows-1),
#    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
#    line        => { color => 'purple' },
#    marker      => { type  => 'none' },
#  );
  $worksheet->insert_chart( 'E19', $chtPPS, 50, 0);

  ## Memory usage chart
  my $chtMem  = $fname->add_chart( type => 'line', embedded => 1);
  $chtMem->set_title ( name => 'Memory Utilization', name_font => { size => 12, bold => 0} );
  $chtMem->set_x_axis( name => 'Time (Seconds)', num_font => { rotation => 45 } );
  $chtMem->set_y_axis( name => 'Memory Usage (MB)', min => 0, max => $memoryMB);
  $chtMem->set_legend( position => 'none' );
  $chtMem->add_series(
    name        => '=chart_data!$D$1',
    values      => '=chart_data!$D$2:$D$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'blue' },
    marker      => { type  => 'none' },
  );
  $worksheet->insert_chart( 'A34', $chtMem, 10, 0);

  ## Concurrency
  my $chtCC   = $fname->add_chart( type => 'line', embedded => 1);
  $chtCC->set_title ( name => 'Concurrency', name_font => { size => 12, bold => 0} );
  $chtCC->set_x_axis( name => 'Time (Seconds)', num_font => { rotation => 45 } );
  $chtCC->set_y_axis( name => 'Concurrent Connections', min => 0);
  $chtCC->set_legend( position => 'bottom' );
  $chtCC->add_series(
    name        => '=chart_data!$I$1',
    values      => '=chart_data!$I$2:$I$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'blue' },
    marker      => { type  => 'none' },
  );
  $chtCC->add_series(
    name        => '=chart_data!$J$1',
    values      => '=chart_data!$J$2:$J$'.($numRows-1),
    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
    line        => { color => 'red' },
    marker      => { type  => 'none' },
  );
## Removing the 'Total Concurrency' data - it's a useless metric
#  $chtCC->add_series(
#    name        => '=chart_data!$N$1',
#    values      => '=chart_data!$N$2:$N$'.($numRows-1),
#    categories  => '=chart_data!$A$2:$A$'.($numRows-1),
#    line        => { color => 'green' },
#    marker      => { type  => 'none' },
#  );
  $worksheet->insert_chart( 'E34', $chtCC, 50, 0);

  return(1);
}

# Close the spreadsheet -- REQUIRED
sub close_xls() {
  my $xls = shift;
  $xls->close();
  return(1);
}

# Serialize and write out the json blob
sub write_json() {
  my $json_file = shift;
  my $json_data = shift;
  my $meta_data = shift;

  $meta_data->{end_time}      = sprintf("%d", Time::HiRes::time);
  $meta_data->{end_time}      += 0;

  $json_data->{metadata} = $test_meta;
  open(JSONOUT, ">", $json_file) or die "Could not open $json_file for writing.\n";
  print JSONOUT encode_json($json_data);
  close(JSONOUT);
}

# saves the data when exiting the program immediately (CTRL+c)
sub exit_now() {
  print "\nStatistics collection cancelled. Attempting to save data.\n";
  $test_meta->{end_time}        = sprintf("%d", Time::HiRes::time);
  $test_meta->{end_time}        += 0;
  $test_meta->{end_time_pretty} = strftime('%F %R', localtime($test_meta->{end_time}));

  if ($JSONOUT && $row > 0) {
    print "Writing JSON: $jsonName\n";
    &write_json($jsonName, \%json_buffer, $test_meta);
  }
  if ($XLSXOUT && $row > 0) {
    print "Writing XLSX: $xlsxName\n";
    &write_chartData($chtdata, \%formats, $row);

    if ($row > 0) {
      &mk_charts($workbook, $charts, $row, $test_meta->{totalMemMB});
      $charts->write("H2", $test_meta->{start_time_pretty},  $formats{text});
      $charts->write("I2", $test_meta->{end_time_pretty},  $formats{text});
    }
    $workbook->close();
  }
  if (($XLSXOUT || $JSONOUT) && ($row < 1)) {
    print "row: $row\n";
    print "\nStatistics collection cancelled, no data collected.\n";
    if ($XLSXOUT) { $workbook->close(); }
  }
  exit(5);
}

# Inserts commas in output columns
sub commify() {
  local $_ = shift;
  1 while s/^(-?\d+)(\d{3})/$1,$2/;
  return $_;
}


# print CLI output using printf + Term::Readkey
sub print_cli() {
  my $out = shift;

  if ($VERBOSE == 1 && $PRETTY == 0) {
    @winSize = &GetTerminalSize;
    if ($iterations == 1 || ($iterations%$winSize[1]) == 0 ) {
      printf("%6s% 7s% 7s% 10s% 8s% 8s% 10s% 9s% 9s% 9s% 9s% 9s% 9s\n",
          "RunTime", "sCPU", "tCPU", "Mem (MB)", "cCPS", "sCPS", "HTTP", "cConns", "sConns", "cIn/Mbs", "cOut/Mbs", "cPPS In", "cPPS Out");
    }
      printf("%7.1f% 7.2f% 7.2f% 10d% 8d% 8d% 10d% 9d% 9d% 9d% 9d% 9d% 9d\n",
          @$out{qw/runTime cpuUtil tmmUtil memUsed cNewConns sNewConns httpReq cCurConns sCurConns cBitsIn cBitsOut cPktsIn cPktsOut/})
  }
  elsif ($VERBOSE == 0 && $PRETTY == 0) {
    @winSize = &GetTerminalSize;
    if ($iterations == 1 || ($iterations%$winSize[1]) == 0 ) {
      printf("%6s% 7s% 10s% 6s% 8s% 10s% 9s% 9s% 9s% 9s\n",
          "RunTime", "tCPU", "Mem (MB)", "cCPS", "sCPS", "HTTP", "cConns", "sConns", "In/Mbs", "Out/Mbs");
    }
    printf("%7.1f% 7.2f% 8d% 8d% 8d% 10d% 9d% 9d% 9d% 9d\n",
        @$out{qw/runTime tmmUtil memUsed cNewConns sNewConns httpReq cCurConns sCurConns cBitsIn cBitsOut/})
  }
# Comma-formatted "pretty" output   '-P'
  if ($VERBOSE == 1 && $PRETTY == 1) {
    @winSize = &GetTerminalSize;
    if ($iterations == 1 || ($iterations%$winSize[1]) == 0 ) {
      printf("% 7s% 8s% 8s% 10s% 10s% 10s% 10s% 12s% 12s% 8s% 9s% 12s% 12s\n",
          "RunTime", "hostCPU", "tmmCPU", "Mem (MB)",
          "cCPS", "sCPS", "HTTP",
          "cConns", "sConns",
          "In/Mbs", "Out/Mbs",
          "cPPS In", "cPPS Out");
    }
    printf("%7.2f %7.2f% 8.2f% 10s% 10s% 10s% 10s% 12s% 12s% 8s% 9s% 12s% 12s\n",
        $out->{runTime}, $out->{cpuUtil}, $out->{tmmUtil}, &commify($out->{memUsed}),
        &commify($out->{cNewConns}), &commify($out->{sNewConns}), &commify($out->{httpReq}),
        &commify($out->{cCurConns}), &commify($out->{sCurConns}),
        &commify($out->{cBitsIn}),   &commify($out->{cBitsOut}),
        &commify($out->{cPktsIn}),   &commify($out->{cPktsOut}));
  }
# Pretty output, but not verbose (removes host CPU column)
  elsif ($VERBOSE == 0 && $PRETTY == 1) {
    @winSize = &GetTerminalSize;
    if ($iterations == 1 || ($iterations%$winSize[1]) == 0 ) {
      printf("% 7s% 8s% 10s% 10s% 10s% 8s% 12s% 12s% 8s% 9s% 12s% 12s\n",
          "RunTime", "tmmCPU", "Mem (MB)",
          "cCPS", "sCPS", "HTTP",
          "cConns", "sConns",
          "In/Mbs", "Out/Mbs",
          "cPPS In", "cPPS Out");
    }
    printf("%7.2f% 8.2f% 10s% 10s% 10s% 8s% 12s% 12s% 8s% 9s% 12s% 12s\n",
        $out->{runTime}, $out->{tmmUtil}, &commify($out->{memUsed}),
        &commify($out->{cNewConns}), &commify($out->{sNewConns}), &commify($out->{httpReq}),
        &commify($out->{cCurConns}), &commify($out->{sCurConns}),
        &commify($out->{cBitsIn}),   &commify($out->{cBitsOut}),
        &commify($out->{cPktsIn}),   &commify($out->{cPktsOut}));
  }
}

# print script usage and exit with the supplied status
sub usage() {
  my $code = shift;

  print <<END;
  USAGE:  $0 -d <host> -l <total test length> -o <output file>
          $0 -h

  -d      IP or hostname to query (REQUIRED)
  -p      UDP port to connect use         (default: 161)
  -c      SNMP community string           (default: public)
  -s      SNMP version                    (default: v2c)
  -l      Full Test duration              (default: 130 seconds)
  -i      Seconds between polling cycles  (default: 10 seconds)
  -o      XLSX output filename            (default: /dev/null)
  -j      JSON output filename            (default: /dev/null)
  -P      Wait time; the amount of time to wait following the start of the 
          test before beginning polling. Should match the ramp-up time (default: 0)
  -v      Verbose output (print verbose stats)
  -P      Pretty output  (Stats with digital grouping)
  -B      Bypass start-of-test detection and start polling immediately
  -h      Print this help text and exit

  -m      IP or hostname to monitor for the start of the test. Use this to 
          monitor the active LTM in a failover pair, but record data from the 
          standby LTM.

END

  exit($code);
}


# vim: set syntax=perl tabstop=2 expandtab:
